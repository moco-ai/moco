# システム比較レポート: ai_manager vs moco

## 1. 概要
本ドキュメントでは、旧世代の `ai_manager`（ツール・Web操作特化型）と、現世代のマルチエージェント・オーケストレーターである `moco` の比較分析を行います。

`ai_manager` が特定の操作を確実に行うための「ツール中心」の設計であったのに対し、`moco` はタスクの内容に応じて動的に最適なエージェントを構成する「プロファイル駆動」の設計へと進化しています。

## 2. システム比較表

| 比較項目 | ai_manager (旧世代) | moco (現世代) |
| :--- | :--- | :--- |
| **アーキテクチャ** | 固定型ルールベース / 手順実行 | **プロファイル駆動型動的オーケストレーション** |
| **設計思想** | Tooling重視（ツールの確実な呼び出し） | **Agentic重視（目的達成のための自律選定）** |
| **拡張性** | コードレベルでのツール追加（静的） | **プロファイルによる役割切り替え / MCP統合** |
| **オーケストレーション** | 定義済みの固定ワークフロー | TaskAnalyzerによる動的プランニング |
| **統合プロトコル** | 独自ラッパー / 非標準 | **MCP (Model Context Protocol)** 完全準拠 |
| **記憶・知見** | 揮発性（セッション内のみ） | **Semantic Memory (FAISS)** による永続化とリコール |
| **最適化** | なし（常に固定ロジック） | Optimizerによるトークン節約・品質追跡 |
| **UI/UX** | CLIまたは特定用途Web UI | 高機能ダッシュボード / **インサイト機能** |

## 3. moco における技術的進化

### 3.1 プロファイル駆動の動的選定
`ai_manager` ではエージェントの役割が固定されていましたが、`moco` では `profiles/` 配下の構成を読み込むことで、1つのシステムが「凄腕プログラマー」「リサーチエキスパート」「デバッガー」など、状況に合わせてエージェント群を動的に入れ替えることが可能です。

### 3.2 MCP (Model Context Protocol) 統合
標準化されたプロトコルである MCP を採用したことにより、独自のツール（Skill）の追加が容易になりました。これにより、Google Search、GitHub、ローカルファイルシステム、さらには独自の外部APIとの連携がシームレスに行えます。

### 3.3 セマンティックメモリとリコール
FAISS（Facebook AI Similarity Search）を用いたベクトルDBにより、過去の会話から重要な知見を「インサイト」として保存します。次回以降、類似のコンテキストが発生した際に自動的にリコール（回想）することで、過去の誤りを避け、成功パターンを再現できます。

## 4. UI/UX の現状と改良ロードマップ

ソースコードの調査により、現在の Web UI には以下の改善が必要であることが特定されました。

### 4.1 特定された不整合・バグ
*   **シンタックスハイライトのクラス不一致**: 
    *   JS側 (`formatter.js`) では `highlight.js` を使用しているが、CSS側 (`code_viewer.css`) には `Prism.js` 特有の `.token` クラスが定義されており、ハイライトが正しく適用されない箇所がある。
*   **テーマ切り替えの連動**: 
    *   本体のダークモード切り替えと、コードビューアー内のテーマが完全に同期していない。

### 4.2 推奨される改善案
1.  **モバイル対応の強化**: 
    *   インサイトパネルをボトムシート化、サイドバーをオーバーレイ形式に修正し、モバイル環境での操作性を向上させる。
2.  **インタラクションの向上**: 
    *   「送信ボタン」を、生成中には「停止ボタン」に切り替える機能の実装。
    *   タイポグラフィの改善（コード領域への `JetBrains Mono` の適用）。
3.  **スクロールの安定化**: 
    *   新規メッセージ受信時の自動スクロールの挙動を、ユーザーが手動でスクロールしている間は一時停止するように調整。

---
*最終更新: 2026-01-20 | moco アーキテクチャドキュメント*
